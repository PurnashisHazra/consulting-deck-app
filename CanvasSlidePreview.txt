import { useState, useEffect, useRef } from "react";
import Draggable from "react-draggable";
import FrameworkDiagram from "./FrameworkDiagram";
import ChartRenderer from "./ChartRenderer";

// Accept setCurrentSlideIndex as a prop for navigation
export default function CanvasSlidePreview({ slides, zoom = 1, currentSlideIndex = 0, setCurrentSlideIndex }) {
  // Delete a canvas item by id
  const handleDelete = (id) => {
    setCanvasItems(items => items.filter(item => item.id !== id));
  };

  // Drag logic
  const handleDrag = (e, data, id) => {
    setCanvasItems(items =>
      items.map(item =>
        item.id === id ? { ...item, x: data.x, y: data.y } : item
      )
    );
  };
  // Store canvas state for each slide
  const [slideCanvasState, setSlideCanvasState] = useState({});

  // Helper to generate default canvas items for a slide
  // Match SlidePreview grid: 1280x720 canvas, 2x2 grid
  // Each cell: 640x360
  // chart: topLeft (0,0), frameworks: topRight (640,0), keyPoints: bottomLeft (0,360), takeaway: bottomRight (640,360)
  const getDefaultCanvasItems = (slide) => {
    if (!slide) return [];
    // Each cell: 640x360, positioned at (0,0) in its grid cell
    return [
      { id: "chart", type: "chart", gridArea: "topLeft", x: 0, y: 0, width: 640, height: 360, data: slide.chart_data, chartType: slide.visualization, chartData: slide.data },
      { id: "frameworks", type: "frameworks", gridArea: "topRight", x: 0, y: 0, width: 640, height: 360, data: slide.frameworks || [], frameworkData: slide.framework_data || {} },
      { id: "keyPoints", type: "keyPoints", gridArea: "bottomLeft", x: 0, y: 0, width: 640, height: 360, data: slide.content || [] },
      { id: "takeaway", type: "takeaway", gridArea: "bottomRight", x: 0, y: 0, width: 640, height: 360, data: { takeaway: slide.takeaway || '', call_to_action: slide.call_to_action || '' } },
    ];
  };

  // Get current slide's canvas items, falling back to default if not set
  const currentSlide = slides && slides.length > 0 ? slides[currentSlideIndex] : null;
  const canvasItems = slideCanvasState[currentSlideIndex] || getDefaultCanvasItems(currentSlide);

  // Save changes to canvas state for current slide
  const setCanvasItems = (newItemsOrUpdater) => {
    setSlideCanvasState(prev => {
      const newItems = typeof newItemsOrUpdater === 'function' ? newItemsOrUpdater(canvasItems) : newItemsOrUpdater;
      return { ...prev, [currentSlideIndex]: newItems };
    });
  };

  // Reset canvas state if slides change (e.g., new deck generated)
  useEffect(() => {
    setSlideCanvasState({});
  }, [slides]);

  // Ensure canvas state for current slide is initialized on navigation
  useEffect(() => {
    if (currentSlide && !slideCanvasState.hasOwnProperty(currentSlideIndex)) {
      setSlideCanvasState(prev => ({
        ...prev,
        [currentSlideIndex]: getDefaultCanvasItems(currentSlide)
      }));
    }
  }, [currentSlideIndex, slides]);

// Helper component to listen for mousemove/up during resize
function ResizeListener({ id, onResize, onResizeEnd }) {
  useEffect(() => {
    const handleMove = (e) => onResize(e, id);
    const handleUp = (e) => {
      onResizeEnd(e, id);
      window.removeEventListener("mousemove", handleMove);
      window.removeEventListener("mouseup", handleUp);
    };
    window.addEventListener("mousemove", handleMove);
    window.addEventListener("mouseup", handleUp);
    return () => {
      window.removeEventListener("mousemove", handleMove);
      window.removeEventListener("mouseup", handleUp);
    };
  }, [id, onResize, onResizeEnd]);
  return null;
}
  // Resize logic
  const handleResizeStart = (e, id) => {
    e.stopPropagation();
    const startX = e.clientX;
    const startY = e.clientY;
    setCanvasItems(items =>
      items.map(item =>
        item.id === id
          ? { ...item, resizing: true, startX, startY, startWidth: item.width, startHeight: item.height }
          : item
      )
    );
    document.body.style.cursor = "nwse-resize";
  };

  const handleResize = (e, id) => {
    setCanvasItems(items =>
      items.map(item => {
        if (item.id === id && item.resizing) {
          const deltaX = e.clientX - item.startX;
          const deltaY = e.clientY - item.startY;
          return {
            ...item,
            width: Math.max(120, item.startWidth + deltaX),
            height: Math.max(80, item.startHeight + deltaY)
          };
        }
        return item;
      })
    );
  };

  const handleResizeEnd = (e, id) => {
    setCanvasItems(items =>
      items.map(item =>
        item.id === id ? { ...item, resizing: false } : item
      )
    );
    document.body.style.cursor = "default";
  };

  return (
    <>
      {/* Linear Flow Navigation */}
      <div className="bg-white border border-gray-200 rounded-lg p-4 mb-4">
        <div className="flex items-center justify-between">
          <button
            onClick={() => setCurrentSlideIndex && setCurrentSlideIndex(Math.max(0, currentSlideIndex - 1))}
            disabled={currentSlideIndex === 0}
            className="flex items-center space-x-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 disabled:bg-gray-50 disabled:text-gray-400 rounded-lg transition-colors"
          >
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
            <span className="text-sm font-medium">Previous</span>
          </button>

          <div className="flex-1 mx-6">
            <div className="flex items-center justify-center space-x-2">
              {slides.map((slide, index) => (
                <div key={slide.slide_number || index} className="flex items-center">
                  <button
                    onClick={() => setCurrentSlideIndex && setCurrentSlideIndex(index)}
                    className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                      index === currentSlideIndex
                        ? 'bg-blue-600 text-white'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    }`}
                  >
                    <div className="text-center">
                      <div className="text-xs text-gray-500 mb-1">Slide {slide.slide_number || index + 1}</div>
                      <div className="max-w-32 truncate">{slide.title}</div>
                    </div>
                  </button>
                  {index < slides.length - 1 && (
                    <svg className="w-4 h-4 text-gray-400 mx-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                    </svg>
                  )}
                </div>
              ))}
            </div>
          </div>

          <button
            onClick={() => setCurrentSlideIndex && setCurrentSlideIndex(Math.min(slides.length - 1, currentSlideIndex + 1))}
            disabled={currentSlideIndex === slides.length - 1}
            className="flex items-center space-x-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 disabled:bg-gray-50 disabled:text-gray-400 rounded-lg transition-colors"
          >
            <span className="text-sm font-medium">Next</span>
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
          </button>
        </div>
      </div>

      {/* Canvas Grid */}
      <div
        className="bg-white border border-gray-300 shadow-lg mx-auto"
        style={{
          width: "100%",
          aspectRatio: "16/9",
          maxWidth: "100%",
          overflow: "hidden",
          display: "grid",
          gridTemplateColumns: "1fr 1fr",
          gridTemplateRows: "1fr 1fr",
          gridTemplateAreas: '"topLeft topRight" "bottomLeft bottomRight"',
          gap: 0
        }}
      >
        {canvasItems.map(item => (
          <div
            key={item.id}
            style={{ gridArea: item.gridArea, position: "relative", width: "100%", height: "100%" }}
          >
            <Draggable
              bounds="parent"
              position={{ x: item.x || 0, y: item.y || 0 }}
              onDrag={(e, data) => handleDrag(e, data, item.id)}
            >
              <div
                className="bg-white border rounded shadow p-4 h-full w-full flex flex-col"
                style={{
                  boxSizing: "border-box",
                  overflow: "hidden",
                  resize: "both",
                  minWidth: 120,
                  minHeight: 80,
                  maxWidth: "100%",
                  maxHeight: "100%"
                }}
              >
              <button
                className="absolute top-2 right-2 text-red-500"
                onClick={() => handleDelete(item.id)}
              >
                âœ•
              </button>
              {/* Resize handle */}
              <div
                className="absolute bottom-1 right-1 w-4 h-4 bg-blue-400 rounded cursor-nwse-resize flex items-center justify-center"
                style={{ zIndex: 10 }}
                onMouseDown={e => handleResizeStart(e, item.id)}
              >
                <svg width="12" height="12" viewBox="0 0 12 12"><polyline points="2,10 10,10 10,2" fill="none" stroke="white" strokeWidth="2"/></svg>
              </div>
              {/* Listen for mousemove/mouseup events for resizing */}
              {item.resizing && (
                <ResizeListener id={item.id} onResize={handleResize} onResizeEnd={handleResizeEnd} />
              )}
              {item.type === "chart" && (
                <>
                  <h4 className="font-bold mb-2">Chart</h4>
                  <div className="flex-1 flex items-center justify-center">
                    <ChartRenderer type={item.chartType} data={item.chartData} />
                  </div>
                </>
              )}
              {item.type === "frameworks" && (
                <>
                  <h4 className="font-bold mb-2">Frameworks</h4>
                  <div className="flex-1 overflow-auto">
                    {item.data && item.data.length > 0 ? (
                      item.data.map((fw, idx) => (
                        <div key={idx} className="mb-2">
                          <div className="font-semibold text-xs mb-1">{fw}</div>
                          <FrameworkDiagram framework={fw} frameworkData={item.frameworkData ? item.frameworkData[fw] : undefined} />
                        </div>
                      ))
                    ) : (
                      <span className="text-xs text-gray-500">No frameworks</span>
                    )}
                  </div>
                </>
              )}
              {item.type === "keyPoints" && (
                <>
                  <h4 className="font-bold mb-2">Key Points</h4>
                  <ul className="list-disc ml-4 flex-1 overflow-auto">
                    {item.data.map((point, i) => (
                      <li key={i} className="text-xs text-gray-700">{point}</li>
                    ))}
                  </ul>
                </>
              )}
              {item.type === "takeaway" && (
                <div className="grid grid-cols-2 gap-4 h-full w-full">
                  <div className="bg-blue-50 border-l-4 border-blue-500 p-3 overflow-auto">
                    <h4 className="text-xs font-semibold text-blue-800 uppercase tracking-wide mb-2">Key Insight</h4>
                    <p className="text-sm text-blue-900">{item.data.takeaway}</p>
                  </div>
                  <div className="bg-green-50 border-l-4 border-green-500 p-3 overflow-auto">
                    <h4 className="text-xs font-semibold text-green-800 uppercase tracking-wide mb-2">Next Steps</h4>
                    <p className="text-sm text-green-900">{item.data.call_to_action}</p>
                  </div>
                </div>
              )}
            </div>
          </Draggable>
        </div>
      ))}
    </div>
    </>
  );
}

// Helper component to listen for mousemove/up during resize
function ResizeListener({ id, onResize, onResizeEnd }) {
  useEffect(() => {
    const handleMove = (e) => onResize(e, id);
    const handleUp = (e) => {
      onResizeEnd(e, id);
      window.removeEventListener("mousemove", handleMove);
      window.removeEventListener("mouseup", handleUp);
    };
    window.addEventListener("mousemove", handleMove);
    window.addEventListener("mouseup", handleUp);
    return () => {
      window.removeEventListener("mousemove", handleMove);
      window.removeEventListener("mouseup", handleUp);
    };
  }, [id, onResize, onResizeEnd]);
  return null;
}
